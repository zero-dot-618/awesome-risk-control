
# 正则表达式-HiveQL示例

## 1. HiveQL中正则相关的运算符或函数

- 关系运算符 `REGEXP` 或 `RLIKE`，使用方式为 `A RLIKE B`、`A REGEXP B`。如果 A 的任意子字符串与 Java 正则表达式 B 能匹配，则返回 TRUE，否则返回 FALSE。当 A 或 B 有一个为 NULL 时，返回 NULL。
- `regexp_extract(string subject, string pattern, int index)`，正则提取，返回string，第一个参数是输入字符串，第二个参数是正则表达式，第三个参数是提取的下标，返回对应下标匹配到的内容。
- `regexp_replace(string INITIAL_STRING, string PATTERN, string REPLACEMENT)`，正则替换，返回string。第一个参数是输入字符串，第二个参数是正则表达式，第三个参数是要替换成的新字符串，返回替换后的结果。

## 2. 字符组

> 字符组（Character Class）就是一组字符，在正则表达式中，它表示“在同一个位置可能出现的各种字符”。
> 
> 写法：[ab]、[314]、[#.?]

### 2.1 字符组的基本用法

字符组的基本用法是用中括号括起来的一组字符：`[...]`。

```sql
-- 以下结果为 true
select '5' rlike '[0123456]';

-- 以下结果为 false
select '5' rlike '[abcd01234]';
```

### 2.2 范围表示法（range）

`[x-y]` 表示 `x` 到 `y` 整个范围内的字符。如，`[0123456789]` 表示为 `[0-9]`，`[abcdefghijk]` 表示为 `[a-k]`。

为什么是`[0-9]`，而不是`[9-0]`？

因为`-`表示的范围一般是根据字符对应的码值（Code Point）来确定的。典型地有 ACSⅡ 编码。在ACSⅡ 编码中，0~9 的码值是 48~57，a~z 的码值是 97~122，A~Z 的码值是 65~90。

```sql
-- 以下结果为 true
select '5' rlike '[0-9]'

-- 以下结果为 false。范围表示法与基本用法可以混用
select '5' rlike '[a-z012]'
```

### 2.3 字符组简记法（shorthands）

字符组简记法提供比范围表示法更简洁的表示方法，如 `\d` 表示 `[0-9]`，`\w` 表示 `[0-9a-zA-z_]`。

常见的字符组简记有：

- `\d` 所有的数字，即 `[0-9]`
- `\D` 所有的非数字，与 `\d` 互斥
- `\w` 所有的单词字符（字符、数字、下划线），即 `[0-9a-zA-Z_]`
- `\W` 所有的非单词字符，与 `\w` 互斥
- `\s` 所有的空白字符，包括空格、制表符、回车符、换行符等空白字符，即 `[ \t\n\x0B\f\r]`
- `\S` 所有的非空白字符，与 `\s` 互斥

```sql
select 
    '1' rlike '\\d'   -- true
    , 'a' rlike '\\d' -- false
    , ' ' rlike '\\s' -- true
    , 'a' rlike '\\w' -- true
```

需要注意的是，简记法中的反斜杠（backslash）`\` 需要两个。这是因为在 Java 中，反斜杠 `\` 后面如果跟字符，会被当做 [Unicode 转义](https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.3)（例如，`\u0061` 代表字符 `a`）或者[转义字符](https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.10.6)（例如，`\n`、`\\r`、`\\` 等），根据转义字符的定义，需要在字符串中表示一个反斜杠时，需要用 `\\`。

### 2.4 元字符与转义

在范围表示法中，字符组中的短横线 `-` 不能匹配短横线字符，而是用来表示范围，这类字符叫做**元字符**（meta-character），它们在字符组内部和外部有着不同的含义。元字符除了 `-` 还有开方括号 `[`、闭刚括号 `]`、`^`、`$`等，它们都有特殊的意义。

当元字符想要表示普通字符的含义时（例如 `-` 就只想表示横线字符），就需要转义处理（在元字符前加反斜线字符 `\`）。对于 `-`，有一个例外情况，就是当它紧跟着字符组中的开括号 `[` 时，它就表示普通横线字符，此时不用转义。

```sql
select 
    '1' rlike '[0-9]'     -- true
    , '1' rlike '[0\\-9]' -- false
    , '-' rlike '[0\\-9]' -- true
```

### 2.5 排除型字符组（Negated Character Class）

在方括号`[…]` 中列出希望匹配的所有字符叫做“普通字符组”。在开方括号 `[` 之后紧跟一个脱字符 `^`，写作 `[^…]`，表示“在当前位置，匹配一个没有列出的字符”。例如，`[^0-9]` 匹配非数字字符。

排除型字符组也可以用于普通字符组内部，例如 `[a-z&&[^m-p]]` 等同于 `[a-lq-z]`。

排除型字符组中的紧跟着开方括号 `[` 的脱字符 `^` 也是元字符，如果要匹配尖括号字符，需要进行转义处理。但是，不紧跟着开方括号 `[` 的 `^` 就是普通字符，不需要转义。

```sql
select
    'A8' rlike '[^0-9][0-9]' -- true
    , '0' rlike '[^0-9]'     -- false
    , '0' rlike '[\\^0-9]'   -- true
    , '^' rlike '[\\^0-9]'   -- true
    , '^' rlike '[0-9^]'     -- true
```

### 2.6 POSIX字符组

POSIX（Portable Operating System Interface for unix），它是一系列规范，定义了UNIX操作系统应当支持的功能，其中也包括了正则表达式的规范。

Java 中有如下 POSIX 字符组：

- `\p{Lower}`，小写的英文字母，即 `[a-z]`
- `\p{Upper}`，大写的英文字母，即 `[A-Z]`
- `\p{ASCII}`，所有 ASCII 字符集，即 `[\x00-\x7F]`
- `\p{Alpha}`，所有的英文字母，即 `[\p{Lower}\p{Upper}]`
- `\p{Digit}`，所有的数字，即 `[0-9]`
- `\p{Alnum}`，所有的英文字母和数字，即 `[\p{Alpha}\p{Digit}]`
- `\p{Punct}`，标点符号，即 !"#$%&'()\*+,-./:;<=>?@[\\]^_\`{|}~ 中的一个
- `\p{Graph}`，可见字符，即 `[\p{Alnum}\p{Punct}]`
- `\p{Print}`，可打印字符，即 `[\p{Graph}\x20]`（可见字符加上空格）
- `\p{Blank}`，空格或制表符，即 `[ \t]`
- `\p{Cntrl}`，控制字符，即 `[\x00-\x1F\x7F]`
- `\p{XDigit}`，十六进制字符，即 `[0-9a-fA-F]`
- `\p{Space}`，空白字符，即 `[ \t\n\x0B\f\r]`


```sql
-- 下面正则表达式中的加号“+”是一个量词，下一章会介绍
select
    regexp_extract('hello world', '\\p{Alpha}+', 0)           -- hello
    , regexp_extract('你是Hello Kitty吗', '\\p{ASCII}+', 0)    -- Hello Kitty
    , regexp_extract('你是Hello Kitty吗', '[^\\p{ASCII}]+', 0) -- 你是
```

## 3 量词

这里首先介绍一下 `^` 和 `$` 两个特殊字符，在上一章的元字符与转义一节提到过这两个特殊字符。

- `^` 放在正则表达式的开头，表示“定位到字符串的起始位置”
- `$` 用在正则表达式的末尾，表示“定位到字符串的结束位置”

```sql
select
    regexp_extract('1a2b', '[a-z]\\d', 0)               -- 结果为"a2"
    , regexp_extract('1a2b', '^[a-z]\\d', 0)            -- 结果为""
    , regexp_extract('1a2b', '^\\d[a-z]', 0)            -- 结果为"1a"
    , regexp_extract('1a2b', '[a-z]\\d$', 0)            -- 结果为""
    , regexp_extract('1a2b', '\\d[a-z]$', 0)            -- 结果为"2b"
    , regexp_extract('1a2b', '^\\d[a-z]$', 0)           -- 结果为""
    , regexp_extract('1a2b', '^\\d[a-z]\\d[a-z]$', 0)   -- 结果为"1a2b"
```

### 3.1 量词的一般形式

如果要匹配一个邮政编码（6位数字），目前能写出来的正则表达式是 `^\d\d\d\d\d\d$`：

`\d` 重复6次的写法很不优雅，正则表达式肯定会有更方便的写法，也就是量词（quantifier）。量词的通用形式是 `{m,n}` （注意，`,` 后面不能有空格），它限定之前的元素能够出现的次数，m是下限，n是上限。其他常见的量词形式有：

- `{n}`，必须出现n次
- `{m,n}`，最少出现m次，最多出现n次
- `{m,}`，最少出现m次，出现次数无上限
- `{0,n}`，可以不出现，也可以出现，最多出现n次

```sql
select
    '100010' rlike '^\\d{6}$'       -- true
    , '123' rlike '^\\d{4,6}$'      -- false
    , '1234' rlike '^\\d{4,6}$'     -- true
    , '123456' rlike '^\\d{4,6}$'   -- true
    , '1234567' rlike '^\\d{4,6}$'  -- false
```

### 3.2 常用量词

正则表达式还有三个常用的量词，分别是 `+`、`?`、`*`：

- `*` 等价于 `{0,}`，可能出现，也可能不出现，出现次数没有上限
- `+` 等价于 `{1，}`，至少出现1次，出现次数没有上限
- `?` 等价于 `{0,1}`，出现0次或1次

这三种量词在实际中使用的非常多。


例如，当需要在商品标题中获取商品重量，就需要用到 `?` 和 `+` 两个量词：

```sql
select
    regexp_extract('清新黄瓜味腰果仁160g', '\\d+[k千]?[g克]', 0)  -- 结果为"160g"
```

### 3.3 点号

点号 `.` 是与量词搭配比较多得一个字符。一般情况下，点号 `.` 可以匹配除了行终止符（`\r`、`\n`、`\u0085`、`\u2028`、`\u2029`）以外的所有字符。

如果启用 DOTALL 模式，则点号 `.` 可以匹配包含行终止符的任意字符，启用方式是在正则表达式前面加上 `(?s)`，它叫做模式修饰符（embedded flag expression），还有 `(?i)`、`(?x)` 等，都有相应的特殊含义。


```sql
select
    'hello world' rlike 'hello.+rld'         -- true
    , 'hello\rworld' rlike 'hello.+rld'      -- false
    , 'hello\nworld' rlike 'hello.+rld'      -- false
    , 'hello\rworld' rlike '(?s)hello.+rld'  -- true
    , 'hello\nworld' rlike '(?s)hello.+rld'  -- true
```


### 3.4 匹配优先量词、忽略优先量词

假设我们要提取一段文本中的书刊名称，根据上面介绍的内容，可以写出如下正则表达式：`《.+》`

```sql
select
    regexp_extract('最喜欢读经典中的《在读书中超越有限的今生》', '《.+》', 0)  -- 《在读书中超越有限的今生》
    , regexp_extract('最喜欢《从法律角度破解电车难题》《在读书中超越有限的今生》', '《.+》', 0) -- 《从法律角度破解电车难题》《在读书中超越有限的今生》
```

但当输入文本为“最喜欢《从法律角度破解电车难题》《在读书中超越有限的今生》”的时候，得到的结果并不符合预期。

这是因为上文介绍的 `*`、`+`、`?` 都是**贪婪两次**（greedy quantifier），它们会尽可能多的匹配。在上面的例子中，`《` 匹配输入中的第一个 `《`，`.+` 则从“从法律……”开始匹配，当匹配到第一个 `》` 时候，因为 `.` 通配符也能匹配 `》`，所以会继续往后匹配，直到第二个 `》`。

正则表达式中可以使用**惰性量词**（reluctant quantifiers）来解决上述问题。与 `*`、`+`、`?`对应的忽略优先量词的形式是 `*?`、`+?`、`??`，忽略优先量词会尽可能少的匹配。

```sql
select
    regexp_extract('最喜欢读经典中的《在读书中超越有限的今生》', '《.+?》', 0),  -- 《在读书中超越有限的今生》
    regexp_extract('最喜欢《从法律角度破解电车难题》《在读书中超越有限的今生》', '《.+?》', 0)  -- 《从法律角度破解电车难题》
```

假设输入为 `最喜欢读经典中的《在读书中超越有限的今生》，罗老师惯有的哲理式自我反省与友善提醒值得每日反省。所泛指的“‘爱读书’带来的优越感和清高”，不正指的是我吗？不过是不学无术的表现罢了。只愿自己能时刻不忘前辈提醒，避免自我欺骗式阅读，在探究真理的路上承认自己的无知，并且心怀谦卑。`，虽然 `《.+》` 能匹配到正确的内容，但从性能角度来说也不是一个推荐的做法。因为 `.+` 会一直匹配到整个输入结束，然后发现后面没有了 `》`，才会往前回退到出现 `》` 的位置。

类似地，量词的一般形式也支持惰性量词：`{m,n}?`、`{m,}?`、`{0,n}?`。


## 4 括号

### 4.1 分组

上一章介绍了量词，上面的例子中量词都只是控制它前面的字符或字符组。那么量词能否控制连续的字符或字符组呢？如控制一个单词 `hello` 出现或者不出现。这就要用到正则表达式的分组功能（子表达式），使用圆括号 `(...)` 实现分组（子表达式）。

```sql
select
    'hello, world' rlike '^hello?, world$',    -- true
    'hell, world' rlike '^hello?, world$',     -- true
    ', world' rlike '^hello?, world$',         -- false
    'hello, world' rlike '^(hello)?, world$',  -- true
    'hell, world' rlike '^(hello)?, world$',   -- false
    ', world' rlike '^(hello)?, world$',       -- true
```

### 4.2 多选结构

多选结构（alternative）的形式是 `(...|...)`，在括号内以竖线 `|` 分开多个子表达式，这些子表达式也叫多选分支（option）。

比如，需要同时匹配多肉桃桃、多肉芒芒两个饮品：`多肉(桃桃|芒芒)`。

### 4.3 引用分组

正则表达式会保存每个 `(...)` 分组匹配的文本，这种功能叫捕获分组（capturing group）。`regexp_extract` 函数的第 3 个参数用于指定提取第几个分组，分组的序号从 1 开始，根据小括号从左到右来确定，序号 0 表示整个表达式匹配的内容。

```sql
select
    regexp_extract('2022-08-15', '(\\d{4})-(\\d{2})-(\\d{2})', 0),  -- 2022-08-15
    regexp_extract('2022-08-15', '(\\d{4})-(\\d{2})-(\\d{2})', 1),  -- 2022
    regexp_extract('2022-08-15', '(\\d{4})-(\\d{2})-(\\d{2})', 2),  -- 08
    regexp_extract('2022-08-15', '(\\d{4})-(\\d{2})-(\\d{2})', 3),  -- 15
```

### 4.4 反向引用

在正则表达式的内部引用表达式前面的捕获分组叫反向引用（back-reference）。具体是用 `\n` （n需要替换为具体数字）来表示引用的分组。


```sql
select
    regexp_extract('种豆得豆', '种(.{1})得\\1', 0),   -- 结果为 "种豆得豆"
    regexp_extract('种瓜得瓜', '种(.{1})得\\1', 0),   -- 结果为 "种瓜得瓜"
    regexp_extract('种豆得瓜', '种(.{1})得\\1', 0),   -- 结果为 ""
```

### 4.5 命名分组

数字编号的分组有时候不够直观，因此有些语言和工具的正则表达式提供了命名分组（named grouping），使用方式是在小括号内开始的位置加上 `?<name>` 来给当前分组命名，在需要使用的地方用 `\k<name>` 来引用。

```sql
select
    regexp_extract('种豆得豆', '种(?<abc>.{1})得\\k<abc>', 0),   -- 结果为 "种豆得豆"
    regexp_extract('种瓜得瓜', '种(?<abc>.{1})得\\k<abc>', 0),   -- 结果为 "种瓜得瓜"
    regexp_extract('种豆得瓜', '种(?<abc>.{1})得\\k<abc>', 0),   -- 结果为 ""
```

### 4.6 非捕获分组

正则表达式默认会保存每个 `(...)` 匹配的文本，利用这个特性可以实现一些有用的功能。但是，有时候正则表达式比较复杂，分组会出现的比较多，而绝大多数分组可能不会被引用（可能只是为了实现多选功能），就可以使用非捕获分组（non-capturing group）来忽略相应分组，它的形式是 `(?:...)`。

```sql
select
    regexp_extract('每千克16.2元', '每(千克|kg|公斤)([\\d\\.]+)', 1),   -- 千克
    regexp_extract('每千克16.2元', '每(?:千克|kg|公斤)([\\d\\.]+)', 1)  -- 16.2
```

## 5 断言

正则表达式中的有些结构不匹配真正的文本，只负责判断在某个位置左、右侧的文本是否符合要求，这种结构称为断言（assertion）。常见的断言有三类：单词边界、行起始/结束位置、环视。

### 5.1 单词边界

单词边界（word boundary)，记为 `\b`。它匹配的是单词边界（一边是单词字符，另一边不是单词字符）的位置，而不是字符。当一个字符不能被 `\w` 匹配时就是单词边界（只对ASCII有效）。另外，用 `\B` 表示非单词边界（non-word boundary）。

```sql
select
    regexp_extract('Let\'s go out for lunch.', '\\b(out)\\b', 1),        -- 结果是 "out"
    regexp_extract('Rick is crazy about football.', '\\b(out)\\b', 1),   -- 结果是 ""
    regexp_extract('他out了', '\\b(out)\\b', 1),  -- 非ASCII码，结果是 ""
    regexp_extract('&out*', '\\b(out)\\b', 1)   -- ASCII吗，结果是 "out"
```

这类匹配位置而不匹配字符的元素叫做锚点（anchor），前面提到过的 `^`、`$` 等也是锚点。

### 5.2 其他边界

除了上面的单词边界 `\b`、`\B`，还有以下边界匹配符：

- `^`：行起始位置
- `$`：行结束位置
- `\A`：字符串起始位置
- `\G`：上一个匹配的结束位置
- `\Z`：字符串结束位置，如果最后一个字符是行终止符，则匹配行终止符之前的位置
- `\z`：字符串结束位置

### 5.3 环视

环视（look-around）用来“停在原地，四处张望”，它本身也不匹配任何字符，用来限定它旁边的文本满足某种条件。

- `(?=...)` 肯定顺序环视。向右看看，右边出现了环视中的内容才匹配
- `(?!...)` 否定顺序环视。向右看看，右边不出现环视中的内容才匹配
- `(?<=...)` 肯定逆序环视。向左看看，左边出现了环视中的内容才匹配
- `(?<!...)` 否定逆序环视。向左看看，左边不出现环视中的内容才匹配

```sql
select
    -- 肯定环视：在前面有数字、后面有3个数字的位置上加入逗号
    regexp_replace('123456789', '(?<=\\d)(?=(\\d{3})+$)', ',') -- "123,456,789"

    -- 否定环视，out前后不能出现字母
    regexp_extract('Let\'s go out for lunch.', '(?<![a-zA-Z])(out)(?![a-zA-Z])', 1),      -- "out"
    regexp_extract('Rick is crazy about football.', '(?<![a-zA-Z])(out)(?![a-zA-Z])', 1), -- ""
    regexp_extract('他out了', '(?<![a-zA-Z])(out)(?![a-zA-Z])', 1),  -- "out"    
```


## 6 匹配模式

前面介绍点号 `.` 的时候，提到过可以在正则表达式前面加上模式修饰符 `(?s)` 来启用 DOTALL 模式。所有的模式修饰符有：

- `(?d)` Unix 行模式，启用后，只有 `\n` 会被当做行终止符（对 `.`、`^`、`$` 有影响）
- `(?i)` 忽略大小写模式，不区分大小写
- `(?x)` 注释模式，开启后会忽略空白字符，而且 `#` 后面的字符会被忽略，直到一行结束
- `(?m)` 多行模式，开启后 `^`、`$` 可以匹配每一行的开始和结束位置，不开启时是匹配完整输入的开始和结束位置
- `(?s)` DOTALL 模式，点号 `.` 可以匹配行终止符
- ` (?u)` UNICODE_CASE 模式，默认情况下，开启 CASE_INSENSITIVE 模式后，只会对 ASCII 支持的支付不区分大小号，同时开启 UNICODE_CASE 模式后，会对 Unicode 字符不区分大小写
- `(?U)` UNICODE_CHARACTER_CLASS 模式，启用 Unicode 版本的字符组简记和 POSIX 字符组。


## 7 参考资料

- 《正则指引》
- [Java 中的 Pattern 类](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html)
- [Hive操作符和UDF](https://cwiki.apache.org/confluence/display/Hive/LanguageManual+UDF)
- [The Java Language Specification](https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html)



